local Types = require(script.Parent.Types)

type Cleanup = Types.Cleanup
type Handler<T...> = Types.Handler<T...>

--[=[
    Observe a changed callback and call a handler with whatever value the changed callback is provided.
]=]
local function ObserveValue<T1, T2>(value: T1, fn: Handler<T1 | T2>): (Cleanup, (T2) -> ())
    local cleanup = fn(value)

    local function onChanged(newValue: T2)
        if cleanup then
            cleanup()
        end

        cleanup = fn(newValue)
    end

    return function()
        if cleanup then
            cleanup()
            cleanup = nil
        end
    end, onChanged
end

--[=[
    Observe an added & removed callback and call a handler any time a value is added.
    The handler will be called with all values that are added.
    When a value is removed, the most recent cleanup will be called.
]=]
local function ObserveArray<T>(values: { T }, fn: Handler<T>): (Cleanup, (T) -> (), (T) -> ())
    local cleanupsByValue = {}

    local function onAdded(value: T)
        local cleanups = cleanupsByValue[value]

        if not cleanups then
            cleanups = {}
            cleanupsByValue[value] = cleanups
        end

        table.insert(cleanups, fn(value) or false)
    end

    local function onRemoved(value: T)
        local cleanups = cleanupsByValue[value]
        local cleanup = cleanups and table.remove(cleanups)

        if cleanup then
            cleanup()
        end

        if not next(cleanups) then
            cleanupsByValue[value] = nil
        end
    end

    -- Initially call the handler with each current value
    for _, value in values do
        onAdded(value)
    end

    return function()
        for _, cleanup in cleanupsByValue do
            cleanup()
        end
        table.clear(cleanupsByValue)
    end, onAdded, onRemoved
end

--[=[
    Observe an added & removed callback and call a handler any time a value is added.
    The handler will be called with all distinct values that are added.
    When a value is removed, the associated cleanup will be called.
]=]
local function ObserveSet<T>(values: { [T]: boolean }, fn: Handler<T>): (Cleanup, (T) -> (), (T) -> ())
    local cleanups = {}

    local function onAdded(value: T)
        if cleanups[value] then
            return
        end

        cleanups[value] = fn(value)
    end

    local function onRemoved(value: T)
        local cleanup = cleanups[value]

        if cleanup then
            cleanup()
            cleanups[value] = nil
        end
    end

    -- Initially call the handler with each current value
    for value, _ in values do
        onAdded(value)
    end

    return function()
        for _, cleanup in cleanups do
            cleanup()
        end
        table.clear(cleanups)
    end, onAdded, onRemoved
end

--[=[
    Observe an added & removed callback and call a handler any time a distinct (non-duplicate) value is added.
    The handler will be called with all distinct values that are added.
    When a value is removed, the associated cleanup will be called.
]=]
local function ObserveDistinctArray<T>(values: {T}, fn: Handler<T>): (Cleanup, (T) -> (), (T) -> ())
    -- TODO: Consider converting the input array to a set and using ObserveSet
    local cleanups = {}

    local function onAdded(value: T)
        if cleanups[value] then
            return
        end

        cleanups[value] = fn(value)
    end

    local function onRemoved(value: T)
        local cleanup = cleanups[value]

        if cleanup then
            cleanup()
            cleanups[value] = nil
        end
    end

    -- Initially call the handler with each current value
    for _, value in values do
        onAdded(value)
    end

    return function()
        for _, cleanup in cleanups do
            cleanup()
        end
        table.clear(cleanups)
    end, onAdded, onRemoved
end

--[=[
    Observe a changed callback and call a handler with the key value pair.
    The handler will be called with all distinct values in the map.
    When a value is changed, the associated cleanup will be called.
]=]
local function ObserveMap<K, V>(values: { [K]: V }, fn: Handler<K, V>): (Cleanup, (K, V) -> ())
    local cleanups = {}

    local function onChanged(key: K, value: V)
        local cleanup = cleanups[key]

        if cleanup then
            cleanup()
        end

        cleanups[key] = fn(key, value)
    end

    -- Initially call the handler with each current value
    for key, value in values do
        onChanged(key, value)
    end

    return function()
        for _, cleanup in cleanups do
            cleanup()
        end
        table.clear(cleanups)
    end, onChanged
end

local State = {
    Value = ObserveValue,
    Array = ObserveArray,
    DistinctArray = ObserveDistinctArray,
    Set = ObserveSet,
    Map = ObserveMap,
}

return State